<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Terrain Explorer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; background: #0f0f1a; color: #fff; height: 100vh; display: flex; flex-direction: column; }
    .header { padding: 12px 16px; background: #1a1a2e; border-bottom: 1px solid #333; }
    .row { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; align-items: center; }
    .btn { padding: 6px 12px; border-radius: 4px; border: none; font-size: 12px; cursor: pointer; background: #374151; color: #fff; }
    .btn.active, .btn.primary { background: #6366f1; }
    .btn.primary { padding: 10px 24px; font-size: 14px; font-weight: 600; }
    .btn:disabled { background: #4b5563; cursor: not-allowed; }
    input[type="text"] { padding: 10px 14px; border-radius: 6px; border: 1px solid #444; background: #252540; color: #fff; font-size: 14px; outline: none; }
    .search-input { flex: 1; min-width: 180px; }
    .coord-input { width: 100px; }
    .controls { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; font-size: 12px; }
    .control-group { display: flex; align-items: center; gap: 6px; }
    .control-group span { color: #9ca3af; }
    input[type="range"] { width: 60px; }
    input[type="checkbox"] { cursor: pointer; }
    .error { color: #f87171; margin-top: 8px; font-size: 13px; }
    .canvas-container { flex: 1; position: relative; overflow: hidden; }
    #canvas { width: 100%; height: 100%; display: block; }
    .overlay { position: absolute; background: rgba(15,15,26,0.9); padding: 12px 16px; border-radius: 8px; font-size: 12px; border: 1px solid #333; }
    .hover-info { top: 12px; right: 12px; font-size: 13px; padding: 8px 12px; }
    .terrain-info { bottom: 12px; left: 12px; max-width: 320px; }
    .terrain-info .name { font-weight: 600; margin-bottom: 6px; color: #a5b4fc; line-height: 1.3; }
    .terrain-info .details { color: #9ca3af; }
    .placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #6b7280; }
    .placeholder .icon { font-size: 56px; margin-bottom: 16px; }
    .placeholder .hint { font-size: 13px; margin-top: 8px; color: #4b5563; }
    .footer { padding: 8px 16px; background: #1a1a2e; border-top: 1px solid #333; font-size: 11px; color: #4b5563; text-align: center; }
  </style>
</head>
<body>
  <div class="header">
    <div class="row">
      <div style="display: flex; gap: 4px; margin-right: 8px;">
        <button class="btn active" id="modeSearch">Search</button>
        <button class="btn" id="modeCoords">Lat/Lon</button>
      </div>
      <div id="searchInputs">
        <input type="text" class="search-input" id="locationInput" placeholder="Search location (e.g., Mount Everest)">
      </div>
      <div id="coordInputs" style="display: none; gap: 8px;">
        <input type="text" class="coord-input" id="latInput" placeholder="Latitude">
        <input type="text" class="coord-input" id="lonInput" placeholder="Longitude">
      </div>
      <button class="btn primary" id="exploreBtn">Explore</button>
    </div>
    <div class="controls">
      <label class="control-group">Area: <input type="range" id="areaSize" min="2" max="50" value="10"> <span id="areaSizeVal">10km</span></label>
      <label class="control-group">Height: <input type="range" id="exaggeration" min="0.5" max="10" step="0.5" value="2"> <span id="exaggerationVal">2x</span></label>
      <div style="display: flex; gap: 4px;">
        <button class="btn active" id="colorTerrain">Terrain</button>
        <button class="btn" id="colorSatellite">Satellite</button>
      </div>
      <label class="control-group" style="cursor: pointer;"><input type="checkbox" id="showContours"> Contours</label>
    </div>
    <div class="error" id="error" style="display: none;"></div>
  </div>
  
  <div class="canvas-container">
    <canvas id="canvas"></canvas>
    <div class="overlay hover-info" id="hoverInfo" style="display: none;">Elevation: <strong id="hoverElev">0</strong>m</div>
    <div class="overlay terrain-info" id="terrainInfo" style="display: none;">
      <div class="name" id="terrainName"></div>
      <div class="details" id="terrainDetails"></div>
    </div>
    <div class="placeholder" id="placeholder">
      <div class="icon">üèîÔ∏è</div>
      <div>Search for any location to explore its terrain</div>
      <div class="hint">Try: Grand Canyon, Mount Fuji, Swiss Alps</div>
    </div>
  </div>
  
  <div class="footer">Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Hover for elevation</div>

<script>
const API_URL = 'https://map-api.psiegel.org';
const GRID_SIZE = 20;

let scene, camera, renderer, mesh, contourLines;
let elevationData = null;
let controls = { theta: 0, phi: Math.PI / 4, radius: 90 };
let isDragging = false, prevX = 0, prevY = 0;
let inputMode = 'search';
let colorMode = 'terrain';
let showContours = false;
let exaggeration = 2;
let areaSize = 10;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function init() {
  const container = document.querySelector('.canvas-container');
  const canvas = document.getElementById('canvas');
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);
  
  camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
  updateCamera();
  
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
  light1.position.set(50, 100, 50);
  scene.add(light1);
  const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
  light2.position.set(-50, 50, -50);
  scene.add(light2);
  
  canvas.addEventListener('mousedown', e => { isDragging = true; prevX = e.clientX; prevY = e.clientY; });
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', () => isDragging = false);
  canvas.addEventListener('mouseleave', () => { isDragging = false; document.getElementById('hoverInfo').style.display = 'none'; });
  canvas.addEventListener('wheel', e => { e.preventDefault(); controls.radius = Math.max(30, Math.min(200, controls.radius + e.deltaY * 0.1)); updateCamera(); }, { passive: false });
  
  canvas.addEventListener('touchstart', e => { if (e.touches.length === 1) { isDragging = true; prevX = e.touches[0].clientX; prevY = e.touches[0].clientY; } });
  canvas.addEventListener('touchmove', e => { if (!isDragging || e.touches.length !== 1) return; e.preventDefault(); controls.theta += (e.touches[0].clientX - prevX) * 0.01; controls.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, controls.phi + (e.touches[0].clientY - prevY) * 0.01)); prevX = e.touches[0].clientX; prevY = e.touches[0].clientY; updateCamera(); }, { passive: false });
  canvas.addEventListener('touchend', () => isDragging = false);
  
  window.addEventListener('resize', () => { camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); });
  
  animate();
  parseURL();
}

function updateCamera() {
  camera.position.x = controls.radius * Math.sin(controls.phi) * Math.sin(controls.theta);
  camera.position.y = controls.radius * Math.cos(controls.phi);
  camera.position.z = controls.radius * Math.sin(controls.phi) * Math.cos(controls.theta);
  camera.lookAt(0, 0, 0);
}

function onMouseMove(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  
  if (isDragging) {
    controls.theta += (e.clientX - prevX) * 0.01;
    controls.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, controls.phi + (e.clientY - prevY) * 0.01));
    prevX = e.clientX; prevY = e.clientY;
    updateCamera();
  }
}

function animate() {
  requestAnimationFrame(animate);
  
  if (mesh && elevationData) {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(mesh);
    const hoverInfo = document.getElementById('hoverInfo');
    if (intersects.length > 0) {
      const { minE, maxE } = elevationData;
      const range = maxE - minE || 1;
      const normalizedY = intersects[0].point.y / (30 * exaggeration);
      const elev = minE + normalizedY * range;
      document.getElementById('hoverElev').textContent = elev.toFixed(0);
      hoverInfo.style.display = 'block';
    } else {
      hoverInfo.style.display = 'none';
    }
  }
  
  renderer.render(scene, camera);
}

function getTerrainColor(t) {
  const stops = [[0,30,100,50],[.15,50,140,50],[.3,120,170,60],[.5,180,165,80],[.7,160,110,70],[.85,130,90,70],[1,255,255,255]];
  let i = 0; while (i < stops.length - 1 && t > stops[i+1][0]) i++;
  const [t1,r1,g1,b1] = stops[i], [t2,r2,g2,b2] = stops[Math.min(i+1, stops.length-1)];
  const f = t2===t1 ? 0 : (t-t1)/(t2-t1);
  return [(r1+(r2-r1)*f)/255, (g1+(g2-g1)*f)/255, (b1+(b2-b1)*f)/255];
}

function getSatelliteColor(t) {
  const stops = [[0,34,85,51],[.2,68,102,51],[.4,119,136,85],[.55,153,153,119],[.7,170,153,136],[.85,200,200,200],[1,255,255,255]];
  let i = 0; while (i < stops.length - 1 && t > stops[i+1][0]) i++;
  const [t1,r1,g1,b1] = stops[i], [t2,r2,g2,b2] = stops[Math.min(i+1, stops.length-1)];
  const f = t2===t1 ? 0 : (t-t1)/(t2-t1);
  return [(r1+(r2-r1)*f)/255, (g1+(g2-g1)*f)/255, (b1+(b2-b1)*f)/255];
}

function buildTerrain() {
  if (!elevationData) return;
  const { elevations, minE, maxE, grid } = elevationData;
  
  if (mesh) { scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); }
  if (contourLines) { scene.remove(contourLines); contourLines.geometry.dispose(); contourLines.material.dispose(); contourLines = null; }
  
  const geo = new THREE.PlaneGeometry(80, 80, grid - 1, grid - 1);
  geo.rotateX(-Math.PI / 2);
  const pos = geo.attributes.position;
  const colors = new Float32Array(pos.count * 3);
  const range = maxE - minE || 1;
  const getColor = colorMode === 'satellite' ? getSatelliteColor : getTerrainColor;
  
  for (let i = 0; i < pos.count; i++) {
    const elev = elevations[i] ?? minE;
    const normalized = (elev - minE) / range;
    pos.setY(i, normalized * 30 * exaggeration);
    const [r, g, b] = getColor(normalized);
    colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
  }
  
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geo.computeVertexNormals();
  
  mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ vertexColors: true, side: THREE.DoubleSide, shininess: 10 }));
  scene.add(mesh);
  
  if (showContours) buildContours();
}

function buildContours() {
  if (!elevationData) return;
  const { elevations, minE, maxE, grid } = elevationData;
  const range = maxE - minE || 1;
  const interval = range > 1000 ? 200 : range > 500 ? 100 : range > 200 ? 50 : 20;
  const points = [];
  const cellSize = 80 / (grid - 1);
  
  for (let level = Math.ceil(minE / interval) * interval; level < maxE; level += interval) {
    const t = (level - minE) / range;
    const y = t * 30 * exaggeration + 0.2;
    
    for (let i = 0; i < grid - 1; i++) {
      for (let j = 0; j < grid - 1; j++) {
        const idx = i * grid + j;
        const e00 = elevations[idx], e10 = elevations[idx + grid], e01 = elevations[idx + 1], e11 = elevations[idx + grid + 1];
        const x0 = -40 + j * cellSize, z0 = -40 + i * cellSize;
        const edges = [];
        if ((e00 < level) !== (e01 < level)) edges.push([x0 + cellSize * (level - e00) / (e01 - e00), z0]);
        if ((e01 < level) !== (e11 < level)) edges.push([x0 + cellSize, z0 + cellSize * (level - e01) / (e11 - e01)]);
        if ((e10 < level) !== (e11 < level)) edges.push([x0 + cellSize * (level - e10) / (e11 - e10), z0 + cellSize]);
        if ((e00 < level) !== (e10 < level)) edges.push([x0, z0 + cellSize * (level - e00) / (e10 - e00)]);
        if (edges.length >= 2) { points.push(new THREE.Vector3(edges[0][0], y, edges[0][1])); points.push(new THREE.Vector3(edges[1][0], y, edges[1][1])); }
      }
    }
  }
  
  if (points.length > 0) {
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    contourLines = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.4, transparent: true }));
    scene.add(contourLines);
  }
}

async function search(query, lat, lon) {
  const btn = document.getElementById('exploreBtn');
  const errorEl = document.getElementById('error');
  btn.disabled = true; btn.textContent = 'Loading...';
  errorEl.style.display = 'none';
  
  try {
    let url = query ? `${API_URL}?q=${encodeURIComponent(query)}&size=${areaSize}&grid=${GRID_SIZE}` : `${API_URL}?lat=${lat}&lon=${lon}&size=${areaSize}&grid=${GRID_SIZE}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    
    elevationData = { elevations: data.elevations, minE: data.minElev, maxE: data.maxElev, grid: data.grid };
    buildTerrain();
    
    document.getElementById('terrainName').textContent = data.name;
    document.getElementById('terrainDetails').innerHTML = `Elevation: ${data.minElev.toFixed(0)}m ‚Äì ${data.maxElev.toFixed(0)}m (${(data.maxElev - data.minElev).toFixed(0)}m range)<br>Center: ${data.center[0].toFixed(4)}¬∞, ${data.center[1].toFixed(4)}¬∞`;
    document.getElementById('terrainInfo').style.display = 'block';
    document.getElementById('placeholder').style.display = 'none';
    
    const params = new URLSearchParams();
    if (query) params.set('q', query); else { params.set('lat', lat); params.set('lon', lon); }
    params.set('size', areaSize); params.set('ex', exaggeration);
    history.replaceState({}, '', '?' + params.toString());
    
  } catch (e) {
    errorEl.textContent = '‚ö†Ô∏è ' + e.message;
    errorEl.style.display = 'block';
  }
  
  btn.disabled = false; btn.textContent = 'Explore';
}

function parseURL() {
  const params = new URLSearchParams(location.search);
  const q = params.get('q'), lat = params.get('lat'), lon = params.get('lon'), size = params.get('size'), ex = params.get('ex');
  if (size) { areaSize = parseInt(size); document.getElementById('areaSize').value = areaSize; document.getElementById('areaSizeVal').textContent = areaSize + 'km'; }
  if (ex) { exaggeration = parseFloat(ex); document.getElementById('exaggeration').value = exaggeration; document.getElementById('exaggerationVal').textContent = exaggeration + 'x'; }
  if (lat && lon) { document.getElementById('latInput').value = lat; document.getElementById('lonInput').value = lon; setInputMode('coords'); setTimeout(() => search(null, lat, lon), 100); }
  else if (q) { document.getElementById('locationInput').value = q; setTimeout(() => search(q), 100); }
}

function setInputMode(mode) {
  inputMode = mode;
  document.getElementById('modeSearch').classList.toggle('active', mode === 'search');
  document.getElementById('modeCoords').classList.toggle('active', mode === 'coords');
  document.getElementById('searchInputs').style.display = mode === 'search' ? 'contents' : 'none';
  document.getElementById('coordInputs').style.display = mode === 'coords' ? 'flex' : 'none';
}

document.getElementById('modeSearch').onclick = () => setInputMode('search');
document.getElementById('modeCoords').onclick = () => setInputMode('coords');
document.getElementById('exploreBtn').onclick = () => inputMode === 'coords' ? search(null, document.getElementById('latInput').value, document.getElementById('lonInput').value) : search(document.getElementById('locationInput').value);
document.getElementById('locationInput').onkeydown = e => { if (e.key === 'Enter') search(e.target.value); };
document.getElementById('latInput').onkeydown = document.getElementById('lonInput').onkeydown = e => { if (e.key === 'Enter') search(null, document.getElementById('latInput').value, document.getElementById('lonInput').value); };
document.getElementById('areaSize').oninput = e => { areaSize = parseInt(e.target.value); document.getElementById('areaSizeVal').textContent = areaSize + 'km'; };
document.getElementById('exaggeration').oninput = e => { exaggeration = parseFloat(e.target.value); document.getElementById('exaggerationVal').textContent = exaggeration + 'x'; buildTerrain(); };
document.getElementById('colorTerrain').onclick = () => { colorMode = 'terrain'; document.getElementById('colorTerrain').classList.add('active'); document.getElementById('colorSatellite').classList.remove('active'); buildTerrain(); };
document.getElementById('colorSatellite').onclick = () => { colorMode = 'satellite'; document.getElementById('colorSatellite').classList.add('active'); document.getElementById('colorTerrain').classList.remove('active'); buildTerrain(); };
document.getElementById('showContours').onchange = e => { showContours = e.target.checked; buildTerrain(); };

init();
</script>
</body>
</html>
